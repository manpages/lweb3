// Generated by CoffeeScript 1.8.0
(function() {
  var Backbone, channelInterface, client, clientChannel, core, helpers, query, server, serverChannel, serverServer, subscriptionMan, v, validator, _;

  _ = require('underscore');

  Backbone = require('backbone4000');

  helpers = require('helpers');

  subscriptionMan = require('subscriptionman2');

  validator = require('validator2-extras');

  v = validator.v;

  core = require('../core');

  query = require('./query');

  channelInterface = core.protocol.extend4000(core.motherShip('channel'), {
    channelsubscribe: function(channelname, pattern, callback) {
      var channel;
      channel = this.channel(channelname);
      if (!callback && pattern.constructor === Function) {
        callback = pattern;
        pattern = true;
      }
      return channel.subscribe(pattern, callback);
    },
    broadcast: function(name, message) {
      return this.channel(name).broadcast(message);
    }
  });

  clientChannel = core.core.extend4000({
    join: function(pattern, callback) {
      var msg, name;
      name = this.get('name');
      this.log('join');
      if (!callback) {
        callback = pattern;
        pattern = void 0;
      }
      if (this.joined) {
        return;
      } else {
        this.joined = true;
      }
      msg = {
        joinChannel: name
      };
      if (pattern) {
        msg.pattern = pattern;
      }
      this.query = this.parent.parent.query(msg, (function(_this) {
        return function(msg) {
          _this.log('#', msg);
          callback(msg);
          return _this.event(msg);
        };
      })(this));
      return this;
    },
    part: function() {
      this.joined = false;
      return this.query.end();
    }
  });

  client = exports.client = channelInterface.extend4000({
    defaults: {
      name: 'channelClient',
      channelClass: clientChannel
    },
    requires: [query.client],
    functions: function() {
      return {
        channel: _.bind(this.channel, this),
        channels: this.channels,
        join: _.bind(this.join, this)
      };
    },
    channelClass: clientChannel,
    join: function(name, pattern, callback) {
      if (!callback) {
        callback = pattern;
        pattern = true;
      }
      return this.channel(name).join(pattern, callback);
    }
  });

  serverChannel = core.core.extend4000({
    initialize: function() {
      var name;
      name = this.get('name');
      this.clients = [];
      return this.log('initialized', name);
    },
    join: function(reply, pattern) {
      this.log('client joined');
      return this.subscribe(pattern || true, function(msg, next) {
        reply.write(msg);
        return next();
      });
    },
    broadcast: function(msg) {
      this.log('broadcast', msg);
      return this.event(msg);
    },
    end: function(msg) {
      _.map(this.clients, function(client) {
        return client.end(msg);
      });
      this.clients = [];
      return core.core.prototype.end.call(this);
    }
  });

  server = exports.server = channelInterface.extend4000({
    defaults: {
      name: 'channelServer',
      channelClass: serverChannel
    },
    requires: [query.server],
    functions: function() {
      return {
        channel: _.bind(this.channel, this),
        channels: this.channels
      };
    },
    initialize: function() {
      core = this.get('core');
      return this.when('parent', (function(_this) {
        return function(parent) {
          parent.onQuery({
            joinChannel: String
          }, function(msg, reply) {
            _this.log("join request received for #" + msg.joinChannel);
            if (core) {
              return core.channel(msg.joinChannel).join(reply, msg.pattern);
            } else {
              return _this.channel(msg.joinChannel).join(reply, msg.pattern);
            }
          });
          return parent.on('end', function() {
            return _this.end();
          });
        };
      })(this));
    }
  });

  serverServer = exports.serverServer = channelInterface.extend4000({
    defaults: {
      name: 'channelServerServer',
      channelClass: serverChannel
    },
    requires: [query.serverServer],
    functions: function() {
      return {
        channel: _.bind(this.channel, this),
        channels: this.channels
      };
    },
    initialize: function() {
      return this.when('parent', (function(_this) {
        return function(parent) {
          parent.on('connect', function(client) {
            return client.addProtocol(new server({
              verbose: _this.verbose,
              core: _this
            }));
          });
          return _.map(parent.clients, function(client, id) {
            return client.addProtocol(new server({
              verbose: _this.verbose,
              core: _this
            }));
          });
        };
      })(this));
    }
  });

}).call(this);
